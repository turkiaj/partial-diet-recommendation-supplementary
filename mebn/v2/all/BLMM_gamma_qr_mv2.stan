
data { 
  int<lower=0> N;   // number of observations
  int<lower=1> p;   // number of predictors
  int<lower=1> J;   // number of groups in data (persons)
  int<lower=1> k;   // number of group-level predictors
  int<lower=1,upper=J> group[N]; //group indicator
  matrix[N,p] X;    // fixed-effect design matrix
  matrix[N,k] Z;    // random-effect design matrix
  vector[N] Y_pk;    // response for P-K 
  vector[N] Y_fppi;  // response for fP-Pi 
  real offset;
} 

transformed data { 
  
  matrix[N,p-1] X_t; // training input
  matrix[N,k] Z_t;   // training input
  vector[N] Y_pk_t;     // training response
  vector[N] Y_fppi_t;   // training response
  int t=1;           // index
  
  // QR reparameteratization of the model matrix

  matrix[N, p-1] Q_ast_pk;
  matrix[N, p-1] Q_ast_fppi;
  matrix[p-1, p-1] R_ast_pk;
  matrix[p-1, p-1] R_ast_fppi;
  matrix[p-1, p-1] R_ast_inverse_pk;
  matrix[p-1, p-1] R_ast_inverse_fppi;

  for (n in 1:N)
  {
    // the intercept is removed from the model matrix 
    X_t[t,1:p-1] = X[n,2:p];
    Z_t[t] = Z[n];
    Y_pk_t[t] = Y_pk[n] + offset;
    Y_fppi_t[t] = Y_fppi[n] + offset;
    t += 1;
  }
  
  // thin and scale the QR decomposition
  Q_ast_pk = qr_thin_Q(X_t) * sqrt(N - 1);
  R_ast_pk = qr_thin_R(X_t) / sqrt(N - 1);
  R_ast_inverse_pk = inverse(R_ast_pk);  

  Q_ast_fppi = qr_thin_Q(X_t) * sqrt(N - 1);
  R_ast_fppi = qr_thin_R(X_t) / sqrt(N - 1);
  R_ast_inverse_fppi = inverse(R_ast_fppi);  

}

parameters { 
  real beta_Intercept_pk;         // intercept 
  real beta_Intercept_fppi;       // intercept 
  vector[p-1] theta_q_pk;         // coefficients on Q_ast
  vector[p-1] theta_q_fppi;       // coefficients on Q_ast
  cholesky_factor_corr[k] L_pk;   // Cholesky factor of group ranef corr matrix
  cholesky_factor_corr[k] L_fppi; // Cholesky factor of group ranef corr matrix
  vector<lower=0>[k] sigma_b_pk;  // group-level random-effect standard deviations
  vector<lower=0>[k] sigma_b_fppi;  // group-level random-effect standard deviations
  vector[k] z_pk[J];              // unscaled group-level effects
  vector[k] z_fppi[J];            // unscaled group-level effects
  real<lower=0> g_log_alpha_pk;   // alpha (shape) parameter of the gamma distribution
  real<lower=0> g_log_alpha_fppi; // alpha (shape) parameter of the gamma distribution
}

transformed parameters {
  real<lower=0> g_alpha_pk;       // alpha (shape) parameter of the gamma distribution
  real<lower=0> g_alpha_fppi;     // alpha (shape) parameter of the gamma distribution
  real<lower=0> sigma_e_pk;       // residual standard deviations 
  real<lower=0> sigma_e_fppi;     // residual standard deviations 
  vector[k] b_pk[J];              // group-level effects (random effects)
  vector[k] b_fppi[J];            // group-level effects (random effects)
  
  // Premultiply diagonal matrix [sigma_b] with the Cholesky decomposition L of
  // the correlation matrix Sigma_b to get variance-covariance matrix of group-level effects

  // local scope for Lambda matrix
  {
    // diag(sigma_b) * L
    matrix[k, k] Lambda_pk;      // Tau * Cholesky decomposition
    matrix[k, k] Lambda_fppi;   // Tau * Cholesky decomposition

    Lambda_pk = diag_pre_multiply(sigma_b_pk, L_pk); 
    Lambda_fppi = diag_pre_multiply(sigma_b_fppi, L_fppi); 
    
    // Group-level effects are generated by multipying D (Sigma_b) with z 
    // that has standard normal distribution
      
    for(j in 1:J) 
      b_pk[j] = Lambda_pk * z_pk[j];    

    for(j in 1:J) 
      b_fppi[j] = Lambda_fppi * z_fppi[j];
  }

  // - log transform alpha parameter to keep it positive
  g_alpha_pk = exp(g_log_alpha_pk);
  g_alpha_fppi = exp(g_log_alpha_fppi);
  
  // estimate of variance 
  // (https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4024993/)
  sigma_e_pk = log(1/g_alpha_pk + 1);
  sigma_e_fppi = log(1/g_alpha_fppi + 1);
}

model {
  
  // Priors
  beta_Intercept_pk ~ cauchy(0,10); // prior for the intercept following Gelman 2008
  beta_Intercept_fppi ~ cauchy(0,10); // prior for the intercept following Gelman 2008

  // for(i in 2:p-1)
  //   beta[i] ~ cauchy(0,2.5); //prior for the slopes following Gelman 2008
   
  sigma_b_pk ~ student_t(3, 0, 10);
  sigma_b_fppi ~ student_t(3, 0, 10);
  
  // brackets introduce a new scope for local variables that are not published in model
  {
    real mu_pk[N];             // linear prediction 
    real mu_fppi[N];           // linear prediction 
    real g_beta_pk[N];         // beta (rate) of Gamma distribution
    real g_beta_fppi[N];       // beta (rate) of Gamma distribution

    // - standard normal prior for random effects
    for (j in 1:J) {
      z_pk[j] ~ normal(0,1);
      z_fppi[j] ~ normal(0,1);
    }
  
    L_pk ~ lkj_corr_cholesky(1);
    L_fppi ~ lkj_corr_cholesky(1);

    for (n in 1:N) 
    {
       //  X_t[n] * beta is reparameterized as Q_ast * theta_q
       mu_pk[n] = beta_Intercept_pk + offset + Q_ast_pk[n] * theta_q_pk + Z_t[n] * b_pk[group[n]];
       mu_fppi[n] = beta_Intercept_fppi + offset + Q_ast_fppi[n] * theta_q_fppi + Z_t[n] * b_fppi[group[n]];

       // identity link
       g_beta_pk[n] = g_alpha_pk / mu_pk[n];
       g_beta_fppi[n] = g_alpha_fppi / mu_fppi[n];
    }
  
    Y_pk_t ~ gamma(g_alpha_pk, g_beta_pk);
    Y_fppi_t ~ gamma(g_alpha_fppi, g_beta_fppi);
  }

}

generated quantities {

  vector[p-1] beta_pk;            // poulation-level effects (fixed effects)
  vector[p-1] beta_fppi;          // poulation-level effects (fixed effects)
  corr_matrix[k] C_pk;            // correlation matrix 
  corr_matrix[k] C_fppi;          // correlation matrix 
  vector[N] Y_rep_pk;             // repeated response
  vector[N] Y_rep_fppi;           // repeated response
  vector[N] log_lik_pk;           // log-likelihood for LOO
  vector[N] log_lik_fppi;         // log-likelihood for LOO
  real mu_pk_hat;
  real mu_fppi_hat;
  real g_beta_pk_hat;
  real g_beta_fppi_hat;
  vector[k-1] personal_effect_pk[J];
  vector[k-1] personal_effect_fppi[J];
  real personal_intercept_pk[J];
  real personal_intercept_fppi[J];

  beta_pk = R_ast_inverse_pk * theta_q_pk;     // coefficients on x
  beta_fppi = R_ast_inverse_pk * theta_q_fppi; // coefficients on x

  // Correlation matrix of random-effects, C = L'L
  C_pk = multiply_lower_tri_self_transpose(L_pk); 
  C_fppi = multiply_lower_tri_self_transpose(L_fppi); 
  
  // Posterior predictive distribution for model checking

  for (n in 1:N) 
  {
    mu_pk_hat = beta_Intercept_pk + offset + X_t[n] * beta_pk + Z_t[n] * b_pk[group[n]];
    mu_fppi_hat = beta_Intercept_fppi + offset + X_t[n] * beta_fppi + Z_t[n] * b_fppi[group[n]];
    
    g_beta_pk_hat = g_alpha_pk / mu_pk_hat;
    g_beta_fppi_hat = g_alpha_fppi / mu_fppi_hat;
    
    Y_rep_pk[n] = gamma_rng(g_alpha_pk, g_beta_pk_hat) - offset;
    Y_rep_fppi[n] = gamma_rng(g_alpha_fppi, g_beta_fppi_hat) - offset;
    
    // Compute log-Likelihood for LOO comparison of the models 
    log_lik_pk[n] = gamma_lpdf(Y_pk_t[n] | g_alpha_pk, g_beta_pk_hat);
    log_lik_fppi[n] = gamma_lpdf(Y_fppi_t[n] | g_alpha_fppi, g_beta_fppi_hat);
  }
  
  // Finally, sample personal effects for each nutrient
  for (j in 1:J) 
  {
    // personal intercept
    personal_intercept_pk[j] = beta_Intercept_pk + b_pk[j][1];
    personal_intercept_fppi[j] = beta_Intercept_fppi + b_fppi[j][1];

    // beta vector does not include intercept, b is also sliced not to include it
    personal_effect_pk[j] = beta_pk + b_pk[j][2:k];
    personal_effect_fppi[j] = beta_fppi + b_fppi[j][2:k];
  }

}


